{#
Log viewer component - Professional terminal design

Usage:
    {% set job = job %}{% set content = log_content %}
    {% include "components/log_viewer.html" %}

Props:
    job: JobMetadata object (for streaming endpoint)
    content: string - initial log content
#}
<div class="log-viewer-container">
    <!-- Header -->
    <div class="log-viewer-header">
        <div class="flex items-center gap-2" style="flex-direction: row">
            <span class="text-xs font-semibold log-header-title">Log Output</span>
            {% if job.status.value == "running" %}
            <span class="text-2xs log-header-live" style="color: var(--green); white-space: nowrap; animation: pulse 2s ease-in-out infinite;">
                Live
            </span>
            {% endif %}
        </div>

        <div class="flex items-center gap-3">
            <!-- Auto-scroll button (hidden by default) -->
            <button id="autoscroll-button"
                    class="text-2xs font-semibold log-header-autoscroll"
                    style="color: var(--green); cursor: pointer; white-space: nowrap; display: none;">
                Enable Auto-scroll
            </button>

            <!-- Refresh button -->
            <button hx-get="/partials/log/{{ job.project or 'general' }}/{{ job.group or 'default' }}/{{ job.name }}/{{ job.run_id }}?tail=100"
                    hx-target="#log-content"
                    hx-swap="innerHTML"
                    class="text-2xs font-semibold log-header-refresh" style="color: var(--gray-3); cursor: pointer; white-space: nowrap;">
                Refresh
            </button>
        </div>
    </div>

    <!-- Log content -->
    <div id="log-container"
         class="log-viewer-body"
         {% if job.status.value == "running" %}
         hx-get="/partials/log/{{ job.project or 'general' }}/{{ job.group or 'default' }}/{{ job.name }}/{{ job.run_id }}?tail=100"
         hx-trigger="every 3s"
         hx-target="#log-content"
         hx-swap="innerHTML"
         {% endif %}>
        <div id="log-content" class="log-content">{{ content | e }}</div>
    </div>
</div>

<!-- Load AnsiUp for ANSI escape sequence parsing -->
<script src="https://cdn.jsdelivr.net/npm/ansi_up@5.2.1/ansi_up.js"></script>

<style>
@keyframes pulse {
    0%, 100% {
        opacity: 1;
    }
    50% {
        opacity: 0.8;
    }
}

.log-viewer-container {
    border: 1px solid var(--gray-3);
    border-radius: 0;
    overflow: hidden;
    background: white;
}

.log-viewer-header {
    background: var(--gray-1);
    border-bottom: 1px solid var(--gray-3);
    padding: var(--spacing-sm) var(--spacing-md);
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: nowrap;
    gap: var(--spacing-sm);
    min-height: 32px;
}

.log-viewer-body {
    height: 600px;
    overflow-y: auto;
    overflow-x: auto;
    padding: var(--spacing-md);
    background: #FAFAFA;
    scrollbar-width: thin;
    scrollbar-color: var(--gray-2) transparent;
    -webkit-overflow-scrolling: touch;
}

.log-viewer-body::-webkit-scrollbar {
    width: 8px;
    height: 8px;
}

.log-viewer-body::-webkit-scrollbar-track {
    background: transparent;
}

.log-viewer-body::-webkit-scrollbar-thumb {
    background: var(--gray-2);
    border-radius: 0;
}

.log-content {
    font-family: 'IBM Plex Mono', monospace;
    font-size: 11px;
    line-height: 1.5;
    white-space: pre-wrap;
    word-break: break-all;
    color: var(--fg);
}

.log-line {
    display: block;
    padding: 1px 0 1px 4px;
    border-left: 2px solid transparent;
    margin-left: -4px;
    cursor: pointer;
}

.log-line:hover {
    background: rgba(0, 0, 0, 0.02);
    border-left-color: var(--gray-2);
}

@media (max-width: 768px) {
    .log-viewer-header {
        gap: var(--spacing-xs);
    }

    .log-viewer-header > div {
        gap: var(--spacing-xs);
        flex-shrink: 1;
        white-space: nowrap;
    }

    .log-header-title {
        flex-shrink: 1;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
    }

    .log-header-live {
        flex-shrink: 0;
    }

    .log-header-refresh {
        flex-shrink: 0;
    }

    .log-viewer-body {
        padding: var(--spacing-sm);
        font-size: 9px;
        overflow-x: hidden;
    }

    .log-content {
        font-size: 9px;
        line-height: 1.3;
    }

    .log-line {
        padding: 1px 0;
        margin-left: 0;
    }

    .log-line-mobile {
        min-height: 16px;
    }

    .log-component-sticky {
        flex-shrink: 0;
    }
}

/* Log level specific styling for light mode */
.log-level-debug { color: #5B6B8A; }
.log-level-info { color: #26A671; }
.log-level-warning { color: #F27200; }
.log-level-error { color: #FF3900; }
.log-level-critical { color: #C62828; }
</style>

<script>
// Initialize ANSI parser
const ansi_up = new AnsiUp();
ansi_up.use_classes = false;

// Log level colors for light mode
const logLevelColors = {
    'DEBUG': '#5B6B8A',
    'INFO': '#26A671',
    'WARNING': '#F27200',
    'WARN': '#F27200',
    'ERROR': '#FF3900',
    'CRITICAL': '#C62828',
    'FATAL': '#C62828'
};

// Simplified log formatting
function formatLogs(element) {
    const rawText = element.textContent || element.innerText;
    const isMobile = window.innerWidth <= 768;

    // Strip ANSI codes for pattern matching
    const stripAnsi = (str) => str.replace(/\x1b\[[0-9;]*m/g, '');

    // Pattern: timestamp | level | source [component |] message
    // Example: 2026-02-04 00:27:32 |  INFO  | (__main__:198) BOOTSTRAP | run_id=...
    // Component is optional - if present, it appears between source and next pipe
    const logPattern = /^(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2})\s*\|\s*([A-Z]+)\s*\|\s*(\([^)]+\))\s+(.*)$/;
    const timestampPattern = /^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}/;

    const lines = rawText.split('\n');
    const formattedLines = lines.map((line, index) => {
        const cleanLine = stripAnsi(line);
        const match = cleanLine.match(logPattern);

        if (match) {
            const [, datetime, level, source, restOfLine] = match;

            // Check if there's a component (text before first pipe in restOfLine)
            const componentMatch = restOfLine.match(/^(.+?)\s*\|\s*(.*)$/);
            const component = componentMatch ? componentMatch[1].trim() : '';
            const message = componentMatch ? componentMatch[2].trim() : restOfLine.trim();
            const time = datetime.substring(11);
            const levelColor = logLevelColors[level.trim().toUpperCase()] || '#2F3338';

            // Simplified source for display
            const sourceMatch = source.match(/([^/.]+\.\w+):(\d+)/);
            const cleanSource = sourceMatch ? `${sourceMatch[1]}:${sourceMatch[2]}` : source;

            // Apply ANSI processing to message
            // Count pipes in clean line to know which pipe marks the message start
            const pipeCount = cleanLine.split('|').length - 1;

            // Find the correct pipe in the original line
            // 2 pipes = timestamp | level | source message (no component)
            // 3 pipes = timestamp | level | source component | message
            let originalMessage;
            if (pipeCount === 2) {
                // No component - message starts after 2nd pipe
                const pipes = line.split('|');
                originalMessage = pipes.slice(2).join('|').trim();
            } else {
                // Has component - message starts after last pipe
                const lastPipeIndex = line.lastIndexOf('|');
                originalMessage = line.substring(lastPipeIndex + 1).trim();
            }
            const msgWithAnsi = originalMessage ? ansi_up.ansi_to_html(originalMessage) : '';

            // Store structured data for copy-to-clipboard
            const dataAttrs = `data-timestamp="${datetime}" data-level="${level.trim()}" data-source="${source}" data-component="${component}" data-message="${message.replace(/"/g, '&quot;')}"`;

            if (isMobile) {
                // Mobile: compact layout with sticky component column
                const levelShort = level.trim().substring(0, 1).toUpperCase(); // First letter only
                const componentSpan = component ? `<span class="log-component-sticky" style="color: #9B59B6; font-weight: 600; font-size: 9px; position: sticky; right: 0; background: linear-gradient(to right, rgba(250,250,250,0) 0%, rgba(250,250,250,0.95) 15%, rgba(250,250,250,1) 25%); padding-left: 20px; padding-right: 4px; min-width: 70px; text-align: right;" title="${source}">${component}</span>` : '';
                return `<div class="log-line log-line-mobile" ${dataAttrs} style="display: flex; font-family: 'IBM Plex Mono', monospace; font-size: 9px; line-height: 1.3; position: relative;">
                    <span style="color: ${levelColor}; font-weight: 600; min-width: 12px; margin-right: 4px;">${levelShort}</span>
                    <span style="color: #2F3338; flex: 1; word-break: break-word; padding-right: ${component ? '70px' : '4px'}; font-weight: 600;">${msgWithAnsi}</span>
                    ${componentSpan}
                </div>`;
            } else {
                // Desktop: full layout with component column
                // Always render component span to maintain alignment, even if empty
                return `<div class="log-line" ${dataAttrs} style="display: flex; font-family: 'IBM Plex Mono', monospace;">
                    <span style="color: #929292; min-width: 60px; font-size: 10px;">${time}</span>
                    <span style="color: ${levelColor}; font-weight: 600; min-width: 55px; font-size: 10px;">${level.trim()}</span>
                    <span style="color: #9B59B6; font-weight: 600; min-width: ${component ? '90px' : '0px'}; font-size: 10px;" title="${source}">${component}</span>
                    <span style="color: #2F3338; flex: 1; padding-left: 8px; font-size: 11px; font-weight: 600;">${msgWithAnsi}</span>
                </div>`;
            }
        } else if (line.trim()) {
            // Check if this is a continuation line (doesn't start with timestamp)
            const isContinuation = !timestampPattern.test(cleanLine);

            if (isContinuation) {
                // Continuation line - indent under the message (without component space)
                const paddingLeft = isMobile ? '16px' : '123px';  // time (60) + level (55) + spacing (8)
                const paddingRight = isMobile ? '75px' : '0';
                const fontSize = isMobile ? '9px' : '11px';
                return `<div class="log-line" style="padding-left: ${paddingLeft}; padding-right: ${paddingRight}; color: #2F3338; font-size: ${fontSize}; font-family: 'IBM Plex Mono', monospace; font-weight: 600;">${ansi_up.ansi_to_html(line)}</div>`;
            } else {
                // Unstructured line with timestamp
                const paddingLeft = isMobile ? '16px' : '123px';
                const paddingRight = isMobile ? '75px' : '0';
                const fontSize = isMobile ? '9px' : '11px';
                return `<div class="log-line" style="padding-left: ${paddingLeft}; padding-right: ${paddingRight}; color: #2F3338; font-size: ${fontSize}; font-family: 'IBM Plex Mono', monospace;">${ansi_up.ansi_to_html(line)}</div>`;
            }
        } else {
            return '<div style="height: 0.5em;"></div>';
        }
    });

    element.innerHTML = formattedLines.join('');
}

// Parse initial content and scroll to bottom
document.addEventListener('DOMContentLoaded', function() {
    const logContent = document.getElementById('log-content');
    if (logContent) {
        formatLogs(logContent);

        // Scroll to bottom on load
        const container = document.getElementById('log-container');
        if (container) {
            container.scrollTop = container.scrollHeight;
        }
    }
});

// Click to copy log line in original format
document.body.addEventListener('click', function(evt) {
    if (evt.target.closest('.log-line')) {
        const logLine = evt.target.closest('.log-line');

        // Check if this is a structured log line (has data attributes)
        const timestamp = logLine.dataset.timestamp;
        const level = logLine.dataset.level;
        const source = logLine.dataset.source;
        const component = logLine.dataset.component;
        const message = logLine.dataset.message;

        let text;
        if (timestamp && level && source) {
            // Reconstruct original format
            if (component) {
                text = `${timestamp} | ${level.padEnd(6)} | ${source} ${component} | ${message}`;
            } else {
                text = `${timestamp} | ${level.padEnd(6)} | ${source} ${message}`;
            }
        } else {
            // Continuation line or unstructured - just copy text
            text = logLine.textContent || logLine.innerText;
        }

        navigator.clipboard.writeText(text).then(function() {
            // Visual feedback
            const originalBg = logLine.style.background;
            logLine.style.background = 'rgba(38, 166, 113, 0.15)';
            setTimeout(function() {
                logLine.style.background = originalBg;
            }, 200);
        }).catch(function(err) {
            console.error('Failed to copy:', err);
        });
    }
});

// Handle HTMX updates
document.body.addEventListener('htmx:beforeSwap', function(evt) {
    if (evt.detail.target.id === 'log-content') {
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = evt.detail.xhr.responseText;
        formatLogs(tempDiv);
        evt.detail.serverResponse = tempDiv.innerHTML;
    }
});

// Auto-scroll management
let autoScrollEnabled = true;
let scrollTimeout;
const autoscrollButton = document.getElementById('autoscroll-button');

// Update button visibility based on autoscroll state
function updateAutoscrollButton() {
    if (autoscrollButton) {
        autoscrollButton.style.display = autoScrollEnabled ? 'none' : 'inline-block';
    }
}

// Enable autoscroll button click handler
if (autoscrollButton) {
    autoscrollButton.addEventListener('click', function() {
        autoScrollEnabled = true;
        updateAutoscrollButton();

        // Scroll to bottom immediately
        const container = document.getElementById('log-container');
        if (container) {
            container.scrollTop = container.scrollHeight;
        }
    });
}

// Detect user scrolling
const logContainer = document.getElementById('log-container');
if (logContainer) {
    logContainer.addEventListener('scroll', function() {
        // Check if user is at bottom
        const isAtBottom = this.scrollHeight - this.scrollTop <= this.clientHeight + 10;

        if (isAtBottom) {
            // User scrolled to bottom, re-enable auto-scroll
            autoScrollEnabled = true;
            updateAutoscrollButton();
        } else {
            // User scrolled away from bottom, disable auto-scroll
            autoScrollEnabled = false;
            updateAutoscrollButton();

            // Re-enable auto-scroll after 5 seconds of no scrolling
            clearTimeout(scrollTimeout);
            scrollTimeout = setTimeout(function() {
                autoScrollEnabled = true;
                updateAutoscrollButton();
            }, 5000);
        }
    });
}

// Auto-scroll to bottom on updates (only if enabled)
document.body.addEventListener('htmx:afterSwap', function(evt) {
    if (evt.detail.target.id === 'log-content' && autoScrollEnabled) {
        const container = document.getElementById('log-container');
        container.scrollTop = container.scrollHeight;
    }
});

// Reformat logs on window resize (maintain scroll position)
let resizeTimeout;
window.addEventListener('resize', function() {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(function() {
        const logContent = document.getElementById('log-content');
        const container = document.getElementById('log-container');
        if (logContent && logContent.textContent) {
            // Check if already scrolled to bottom before reformatting
            const isAtBottom = container.scrollHeight - container.scrollTop <= container.clientHeight + 50;
            formatLogs(logContent);
            // Keep at bottom if was at bottom
            if (isAtBottom) {
                container.scrollTop = container.scrollHeight;
            }
        }
    }, 250);
});
</script>
