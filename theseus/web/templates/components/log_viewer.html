{#
Log viewer component - Professional terminal design

Usage:
    {% set job = job %}{% set content = log_content %}
    {% include "components/log_viewer.html" %}

Props:
    job: JobMetadata object (for streaming endpoint)
    content: string - initial log content
#}
<div class="log-viewer-container">
    <!-- Header -->
    <div class="log-viewer-header">
        <div class="flex items-center gap-2" style="flex-direction: row">
            <span class="text-xs font-semibold log-header-title">Log Output</span>
            {% if job.status.value == "running" %}
            <span class="text-2xs log-header-live" style="color: var(--green); white-space: nowrap; animation: pulse 2s ease-in-out infinite;">
                Live
            </span>
            {% endif %}
        </div>

        <div class="flex items-center gap-3">
            <!-- Auto-scroll button (hidden by default) -->
            <button id="autoscroll-button"
                    class="text-2xs font-semibold log-header-autoscroll"
                    style="color: var(--green); cursor: pointer; white-space: nowrap; display: none;">
                Enable Auto-scroll
            </button>

            <!-- Refresh button -->
            <button hx-get="/partials/log/{{ job.project or 'general' }}/{{ job.group or 'default' }}/{{ job.name }}/{{ job.run_id }}"
                    hx-target="#log-content"
                    hx-swap="innerHTML"
                    class="text-2xs font-semibold log-header-refresh" style="color: var(--gray-3); cursor: pointer; white-space: nowrap;">
                Refresh
            </button>
        </div>
    </div>

    <!-- Log content -->
    <div id="log-container"
         class="log-viewer-body"
         {% if job.status.value == "running" %}
         hx-get="/partials/log/{{ job.project or 'general' }}/{{ job.group or 'default' }}/{{ job.name }}/{{ job.run_id }}"
         hx-trigger="every 3s"
         hx-target="#log-content"
         hx-swap="innerHTML"
         {% endif %}>
        <div id="log-content" class="log-content">{{ content | e }}</div>
    </div>
</div>

<!-- Load AnsiUp for ANSI escape sequence parsing -->
<script src="https://cdn.jsdelivr.net/npm/ansi_up@5.2.1/ansi_up.js"></script>

<style>
@keyframes pulse {
    0%, 100% {
        opacity: 1;
    }
    50% {
        opacity: 0.8;
    }
}

.log-viewer-container {
    border: 1px solid var(--gray-3);
    border-radius: 0;
    overflow: hidden;
    background: white;
}

.log-viewer-header {
    background: var(--gray-1);
    border-bottom: 1px solid var(--gray-3);
    padding: var(--spacing-sm) var(--spacing-md);
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: nowrap;
    gap: var(--spacing-sm);
    min-height: 32px;
}

.log-viewer-body {
    height: 600px;
    overflow-y: auto;
    overflow-x: auto;
    padding: var(--spacing-md);
    background: #FAFAFA;
    scrollbar-width: thin;
    scrollbar-color: var(--gray-2) transparent;
    -webkit-overflow-scrolling: touch;
}

.log-viewer-body::-webkit-scrollbar {
    width: 8px;
    height: 8px;
}

.log-viewer-body::-webkit-scrollbar-track {
    background: transparent;
}

.log-viewer-body::-webkit-scrollbar-thumb {
    background: var(--gray-2);
    border-radius: 0;
}

.log-content {
    font-family: 'IBM Plex Mono', monospace;
    font-size: 11px;
    line-height: 1.5;
    white-space: pre-wrap;
    word-break: break-all;
    color: var(--fg);
}

/* Structured log line - responsive layout via CSS */
.log-structured {
    display: flex;
    font-family: 'IBM Plex Mono', monospace;
    padding: 1px 0 1px 4px;
    border-left: 2px solid transparent;
    margin-left: -4px;
    cursor: pointer;
}

.log-structured:hover {
    background: rgba(0, 0, 0, 0.02);
    border-left-color: var(--gray-2);
}

/* Desktop layout (default) */
.log-time {
    color: #929292;
    min-width: 60px;
    font-size: 10px;
}

.log-level {
    font-weight: 600;
    min-width: 55px;
    font-size: 10px;
}

.log-component {
    color: #9B59B6;
    font-weight: 600;
    min-width: 90px;
    font-size: 10px;
}

.log-message {
    color: #2F3338;
    flex: 1;
    padding-left: 8px;
    font-size: 11px;
    font-weight: 600;
    word-break: break-word;
}

/* Continuation lines */
.log-continuation {
    padding-left: 123px; /* time (60) + level (55) + spacing (8) */
    color: #2F3338;
    font-size: 11px;
    font-family: 'IBM Plex Mono', monospace;
    font-weight: 600;
}

.log-empty {
    height: 0.5em;
}

/* Mobile layout */
@media (max-width: 768px) {
    .log-time {
        display: none; /* Hide timestamp on mobile */
    }

    .log-level {
        min-width: 12px;
        margin-right: 4px;
        font-size: 9px;
    }

    .log-component {
        position: absolute;
        right: 4px;
        min-width: 70px;
        font-size: 9px;
        text-align: right;
        background: linear-gradient(to right, rgba(250,250,250,0) 0%, rgba(250,250,250,0.95) 15%, rgba(250,250,250,1) 25%);
        padding-left: 20px;
    }

    .log-message {
        flex: 1;
        padding-right: 75px; /* Space for component */
        padding-left: 0;
        font-size: 9px;
    }

    .log-structured {
        position: relative;
        font-size: 9px;
        line-height: 1.3;
    }

    .log-continuation {
        padding-left: 16px;
        padding-right: 75px;
        font-size: 9px;
        line-height: 1.3;
    }
}


/* Mobile adjustments for header */
@media (max-width: 768px) {
    .log-viewer-header {
        gap: var(--spacing-xs);
    }

    .log-viewer-body {
        padding: var(--spacing-sm);
    }
}
</style>

<script>
// Initialize ANSI parser
const ansi_up = new AnsiUp();
ansi_up.use_classes = false;

// Log level colors for light mode
const logLevelColors = {
    'DEBUG': '#5B6B8A',
    'INFO': '#26A671',
    'WARNING': '#F27200',
    'WARN': '#F27200',
    'ERROR': '#FF3900',
    'CRITICAL': '#C62828',
    'FATAL': '#C62828'
};

// Simplified log formatting - formats once, CSS handles responsive layout
function formatLogs(element) {
    const rawText = element.textContent || element.innerText;
    if (!rawText || !rawText.trim()) {
        return; // Nothing to format
    }

    // Strip ANSI codes for pattern matching
    const stripAnsi = (str) => str.replace(/\x1b\[[0-9;]*m/g, '');

    // Pattern: timestamp | level | source [component |] message
    // Example: 2026-02-04 00:27:32 |  INFO  | (__main__:198) BOOTSTRAP | run_id=...
    // Component is optional - if present, it appears between source and next pipe
    const logPattern = /^(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2})\s*\|\s*([A-Z]+)\s*\|\s*(\([^)]+\))\s+(.*)$/;
    const timestampPattern = /^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}/;

    const lines = rawText.split('\n');
    const formattedLines = lines.map((line, index) => {
        const cleanLine = stripAnsi(line);
        const match = cleanLine.match(logPattern);

        if (match) {
            const [, datetime, level, source, restOfLine] = match;

            // Check if there's a component (text before first pipe in restOfLine)
            const componentMatch = restOfLine.match(/^(.+?)\s*\|\s*(.*)$/);
            const component = componentMatch ? componentMatch[1].trim() : '';
            const message = componentMatch ? componentMatch[2].trim() : restOfLine.trim();
            const time = datetime.substring(11);
            const levelColor = logLevelColors[level.trim().toUpperCase()] || '#2F3338';

            // Apply ANSI processing to message
            const pipeCount = cleanLine.split('|').length - 1;
            let originalMessage;
            if (pipeCount === 2) {
                const pipes = line.split('|');
                originalMessage = pipes.slice(2).join('|').trim();
            } else {
                const lastPipeIndex = line.lastIndexOf('|');
                originalMessage = line.substring(lastPipeIndex + 1).trim();
            }
            const msgWithAnsi = originalMessage ? ansi_up.ansi_to_html(originalMessage) : '';

            // Store structured data
            const dataAttrs = `data-timestamp="${datetime}" data-level="${level.trim()}" data-source="${source}" data-component="${component}" data-message="${message.replace(/"/g, '&quot;')}"`;

            // Single responsive layout - CSS handles mobile/desktop
            return `<div class="log-line log-structured" ${dataAttrs}>
                <span class="log-time">${time}</span>
                <span class="log-level" style="color: ${levelColor};">${level.trim()}</span>
                <span class="log-component" title="${source}">${component}</span>
                <span class="log-message">${msgWithAnsi}</span>
            </div>`;
        } else if (line.trim()) {
            // Continuation or unstructured line
            const isContinuation = !timestampPattern.test(cleanLine);
            return `<div class="log-line log-continuation">${ansi_up.ansi_to_html(line)}</div>`;
        } else {
            return '<div class="log-line log-empty"></div>';
        }
    });

    element.innerHTML = formattedLines.join('');
}

// Parse initial content and scroll to bottom
function initializeLogs() {
    const logContent = document.getElementById('log-content');
    const container = document.getElementById('log-container');

    if (logContent && logContent.textContent && logContent.textContent.trim()) {
        try {
            formatLogs(logContent);

            // Scroll to bottom after formatting
            if (container) {
                // Use setTimeout to ensure DOM has updated
                setTimeout(() => {
                    container.scrollTop = container.scrollHeight;
                }, 50);
            }
        } catch (err) {
            console.error('Error formatting logs:', err);
            // Leave raw text as fallback
        }
    }
}

// Initialize on DOMContentLoaded
document.addEventListener('DOMContentLoaded', initializeLogs);

// Also try to initialize immediately if DOM is already loaded
if (document.readyState === 'loading') {
    // DOMContentLoaded has not fired yet
} else {
    // DOMContentLoaded has already fired
    initializeLogs();
}

// Click to copy log line in original format
document.body.addEventListener('click', function(evt) {
    if (evt.target.closest('.log-line')) {
        const logLine = evt.target.closest('.log-line');

        // Check if this is a structured log line (has data attributes)
        const timestamp = logLine.dataset.timestamp;
        const level = logLine.dataset.level;
        const source = logLine.dataset.source;
        const component = logLine.dataset.component;
        const message = logLine.dataset.message;

        let text;
        if (timestamp && level && source) {
            // Reconstruct original format
            if (component) {
                text = `${timestamp} | ${level.padEnd(6)} | ${source} ${component} | ${message}`;
            } else {
                text = `${timestamp} | ${level.padEnd(6)} | ${source} ${message}`;
            }
        } else {
            // Continuation line or unstructured - just copy text
            text = logLine.textContent || logLine.innerText;
        }

        navigator.clipboard.writeText(text).then(function() {
            // Visual feedback
            const originalBg = logLine.style.background;
            logLine.style.background = 'rgba(38, 166, 113, 0.15)';
            setTimeout(function() {
                logLine.style.background = originalBg;
            }, 200);
        }).catch(function(err) {
            console.error('Failed to copy:', err);
        });
    }
});

// Handle HTMX updates
document.body.addEventListener('htmx:beforeSwap', function(evt) {
    if (evt.detail.target.id === 'log-content') {
        try {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = evt.detail.xhr.responseText;

            // Only format if there's actual content
            if (tempDiv.textContent && tempDiv.textContent.trim()) {
                formatLogs(tempDiv);
                evt.detail.serverResponse = tempDiv.innerHTML;
            }
        } catch (err) {
            console.error('Error formatting HTMX update:', err);
            // Let HTMX use the raw response as fallback
        }
    }
});

// Auto-scroll management
let autoScrollEnabled = true;
let scrollTimeout;
const autoscrollButton = document.getElementById('autoscroll-button');

// Update button visibility based on autoscroll state
function updateAutoscrollButton() {
    if (autoscrollButton) {
        autoscrollButton.style.display = autoScrollEnabled ? 'none' : 'inline-block';
    }
}

// Enable autoscroll button click handler
if (autoscrollButton) {
    autoscrollButton.addEventListener('click', function() {
        autoScrollEnabled = true;
        updateAutoscrollButton();

        // Scroll to bottom immediately
        const container = document.getElementById('log-container');
        if (container) {
            container.scrollTop = container.scrollHeight;
        }
    });
}

// Detect user scrolling
const logContainer = document.getElementById('log-container');
if (logContainer) {
    logContainer.addEventListener('scroll', function() {
        // Check if user is at bottom
        const isAtBottom = this.scrollHeight - this.scrollTop <= this.clientHeight + 10;

        if (isAtBottom) {
            // User scrolled to bottom, re-enable auto-scroll
            autoScrollEnabled = true;
            updateAutoscrollButton();
        } else {
            // User scrolled away from bottom, disable auto-scroll
            autoScrollEnabled = false;
            updateAutoscrollButton();

            // Re-enable auto-scroll after 5 seconds of no scrolling
            clearTimeout(scrollTimeout);
            scrollTimeout = setTimeout(function() {
                autoScrollEnabled = true;
                updateAutoscrollButton();
            }, 5000);
        }
    });
}

// Auto-scroll to bottom on updates (only if enabled)
document.body.addEventListener('htmx:afterSwap', function(evt) {
    if (evt.detail.target.id === 'log-content' && autoScrollEnabled) {
        const container = document.getElementById('log-container');
        container.scrollTop = container.scrollHeight;
    }
});

// No resize handler needed - CSS handles responsive layout!
</script>
